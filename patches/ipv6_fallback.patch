diff --git a/crates/slipstream-client/src/runtime/setup.rs b/crates/slipstream-client/src/runtime/setup.rs
index 1234567..abcdefg 100644
--- a/crates/slipstream-client/src/runtime/setup.rs
+++ b/crates/slipstream-client/src/runtime/setup.rs
@@ -1,5 +1,5 @@
 use crate::error::ClientError;
-use std::net::{Ipv6Addr, SocketAddr, SocketAddrV6};
+use std::net::{Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};
 use tokio::net::UdpSocket as TokioUdpSocket;
 
 pub(crate) fn compute_mtu(domain_len: usize) -> Result<u32, ClientError> {
@@ -18,8 +18,15 @@ pub(crate) fn compute_mtu(domain_len: usize) -> Result<u32, ClientError> {
 }
 
 pub(crate) async fn bind_udp_socket() -> Result<TokioUdpSocket, ClientError> {
-    let bind_addr = SocketAddr::V6(SocketAddrV6::new(Ipv6Addr::UNSPECIFIED, 0, 0, 0));
-    TokioUdpSocket::bind(bind_addr).await.map_err(map_io)
+    // Try IPv6 dual-stack first (works on most systems), fall back to IPv4
+    let bind_addr_v6 = SocketAddr::V6(SocketAddrV6::new(Ipv6Addr::UNSPECIFIED, 0, 0, 0));
+    match TokioUdpSocket::bind(bind_addr_v6).await {
+        Ok(socket) => Ok(socket),
+        Err(_) => {
+            // Fall back to IPv4 if IPv6 is not available (common on Windows)
+            let bind_addr_v4 = SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::UNSPECIFIED, 0));
+            TokioUdpSocket::bind(bind_addr_v4).await.map_err(map_io)
+        }
+    }
 }
 
 pub(crate) fn map_io(err: std::io::Error) -> ClientError {
